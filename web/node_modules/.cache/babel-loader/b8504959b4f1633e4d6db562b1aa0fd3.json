{"ast":null,"code":"import * as fcl from \"@onflow/fcl\";\nimport * as t from \"@onflow/types\";\nimport { tx } from \"./util/tx\";\nconst CODE = fcl.cdc`\n  import FungibleToken from 0xFungibleToken\n  import NonFungibleToken from 0xNonFungibleToken\n  import Kibble from 0xKibble\n  import KittyItems from 0xKittyItems\n  import KittyItemsMarket from 0xKittyItemsMarket\n\n  transaction(itemID: UInt64, price: UFix64) {\n    let kibbleVault: Capability<&Kibble.Vault{FungibleToken.Receiver}>\n    let kittyItemsCollection: Capability<&KittyItems.Collection{NonFungibleToken.Provider, KittyItems.KittyItemsCollectionPublic}>\n    let marketCollection: &KittyItemsMarket.Collection\n\n    prepare(signer: AuthAccount) {\n        // we need a provider capability, but one is not provided by default so we create one.\n        let KittyItemsCollectionProviderPrivatePath = /private/kittyItemsCollectionProvider\n\n        self.kibbleVault = signer.getCapability<&Kibble.Vault{FungibleToken.Receiver}>(Kibble.ReceiverPublicPath)!\n        assert(self.kibbleVault.borrow() != nil, message: \"Missing or mis-typed Kibble receiver\")\n\n        if !signer.getCapability<&KittyItems.Collection{NonFungibleToken.Provider, KittyItems.KittyItemsCollectionPublic}>(KittyItemsCollectionProviderPrivatePath)!.check() {\n            signer.link<&KittyItems.Collection{NonFungibleToken.Provider, KittyItems.KittyItemsCollectionPublic}>(KittyItemsCollectionProviderPrivatePath, target: KittyItems.CollectionStoragePath)\n        }\n\n        self.kittyItemsCollection = signer.getCapability<&KittyItems.Collection{NonFungibleToken.Provider, KittyItems.KittyItemsCollectionPublic}>(KittyItemsCollectionProviderPrivatePath)!\n        assert(self.kittyItemsCollection.borrow() != nil, message: \"Missing or mis-typed KittyItemsCollection provider\")\n\n        self.marketCollection = signer.borrow<&KittyItemsMarket.Collection>(from: KittyItemsMarket.CollectionStoragePath)\n            ?? panic(\"Missing or mis-typed KittyItemsMarket Collection\")\n    }\n\n    execute {\n        let offer <- KittyItemsMarket.createSaleOffer (\n            sellerItemProvider: self.kittyItemsCollection,\n            itemID: itemID,\n            typeID: self.kittyItemsCollection.borrow()!.borrowKittyItem(id: itemID)!.typeID,\n            sellerPaymentReceiver: self.kibbleVault,\n            price: price\n        )\n        self.marketCollection.insert(offer: <-offer)\n    }\n}\n`;\nexport function createSaleOffer({\n  itemID,\n  price\n}, opts = {}) {\n  if (itemID == null) throw new Error(\"createSaleOffer(itemID, price) -- itemID required\");\n  if (price == null) throw new Error(\"createSaleOffer(itemID, price) -- price required\"); // prettier-ignore\n\n  return tx([fcl.transaction(CODE), fcl.args([fcl.arg(Number(itemID), t.UInt64), fcl.arg(String(price), t.UFix64)]), fcl.proposer(fcl.authz), fcl.payer(fcl.authz), fcl.authorizations([fcl.authz]), fcl.limit(1000)], opts);\n}","map":{"version":3,"sources":["/Users/wuchao/flow/nft/ToyWorld/web/src/flow/create-sale-offer.tx.js"],"names":["fcl","t","tx","CODE","cdc","createSaleOffer","itemID","price","opts","Error","transaction","args","arg","Number","UInt64","String","UFix64","proposer","authz","payer","authorizations","limit"],"mappings":"AAAA,OAAO,KAAKA,GAAZ,MAAqB,aAArB;AACA,OAAO,KAAKC,CAAZ,MAAmB,eAAnB;AACA,SAAQC,EAAR,QAAiB,WAAjB;AAEA,MAAMC,IAAI,GAAGH,GAAG,CAACI,GAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAzCA;AA2CA,OAAO,SAASC,eAAT,CAAyB;AAACC,EAAAA,MAAD;AAASC,EAAAA;AAAT,CAAzB,EAA0CC,IAAI,GAAG,EAAjD,EAAqD;AAC1D,MAAIF,MAAM,IAAI,IAAd,EACE,MAAM,IAAIG,KAAJ,CAAU,mDAAV,CAAN;AACF,MAAIF,KAAK,IAAI,IAAb,EACE,MAAM,IAAIE,KAAJ,CAAU,kDAAV,CAAN,CAJwD,CAM1D;;AACA,SAAOP,EAAE,CAAC,CACRF,GAAG,CAACU,WAAJ,CAAgBP,IAAhB,CADQ,EAERH,GAAG,CAACW,IAAJ,CAAS,CACPX,GAAG,CAACY,GAAJ,CAAQC,MAAM,CAACP,MAAD,CAAd,EAAwBL,CAAC,CAACa,MAA1B,CADO,EAEPd,GAAG,CAACY,GAAJ,CAAQG,MAAM,CAACR,KAAD,CAAd,EAAuBN,CAAC,CAACe,MAAzB,CAFO,CAAT,CAFQ,EAMRhB,GAAG,CAACiB,QAAJ,CAAajB,GAAG,CAACkB,KAAjB,CANQ,EAORlB,GAAG,CAACmB,KAAJ,CAAUnB,GAAG,CAACkB,KAAd,CAPQ,EAQRlB,GAAG,CAACoB,cAAJ,CAAmB,CACjBpB,GAAG,CAACkB,KADa,CAAnB,CARQ,EAWRlB,GAAG,CAACqB,KAAJ,CAAU,IAAV,CAXQ,CAAD,EAYNb,IAZM,CAAT;AAaD","sourcesContent":["import * as fcl from \"@onflow/fcl\"\nimport * as t from \"@onflow/types\"\nimport {tx} from \"./util/tx\"\n\nconst CODE = fcl.cdc`\n  import FungibleToken from 0xFungibleToken\n  import NonFungibleToken from 0xNonFungibleToken\n  import Kibble from 0xKibble\n  import KittyItems from 0xKittyItems\n  import KittyItemsMarket from 0xKittyItemsMarket\n\n  transaction(itemID: UInt64, price: UFix64) {\n    let kibbleVault: Capability<&Kibble.Vault{FungibleToken.Receiver}>\n    let kittyItemsCollection: Capability<&KittyItems.Collection{NonFungibleToken.Provider, KittyItems.KittyItemsCollectionPublic}>\n    let marketCollection: &KittyItemsMarket.Collection\n\n    prepare(signer: AuthAccount) {\n        // we need a provider capability, but one is not provided by default so we create one.\n        let KittyItemsCollectionProviderPrivatePath = /private/kittyItemsCollectionProvider\n\n        self.kibbleVault = signer.getCapability<&Kibble.Vault{FungibleToken.Receiver}>(Kibble.ReceiverPublicPath)!\n        assert(self.kibbleVault.borrow() != nil, message: \"Missing or mis-typed Kibble receiver\")\n\n        if !signer.getCapability<&KittyItems.Collection{NonFungibleToken.Provider, KittyItems.KittyItemsCollectionPublic}>(KittyItemsCollectionProviderPrivatePath)!.check() {\n            signer.link<&KittyItems.Collection{NonFungibleToken.Provider, KittyItems.KittyItemsCollectionPublic}>(KittyItemsCollectionProviderPrivatePath, target: KittyItems.CollectionStoragePath)\n        }\n\n        self.kittyItemsCollection = signer.getCapability<&KittyItems.Collection{NonFungibleToken.Provider, KittyItems.KittyItemsCollectionPublic}>(KittyItemsCollectionProviderPrivatePath)!\n        assert(self.kittyItemsCollection.borrow() != nil, message: \"Missing or mis-typed KittyItemsCollection provider\")\n\n        self.marketCollection = signer.borrow<&KittyItemsMarket.Collection>(from: KittyItemsMarket.CollectionStoragePath)\n            ?? panic(\"Missing or mis-typed KittyItemsMarket Collection\")\n    }\n\n    execute {\n        let offer <- KittyItemsMarket.createSaleOffer (\n            sellerItemProvider: self.kittyItemsCollection,\n            itemID: itemID,\n            typeID: self.kittyItemsCollection.borrow()!.borrowKittyItem(id: itemID)!.typeID,\n            sellerPaymentReceiver: self.kibbleVault,\n            price: price\n        )\n        self.marketCollection.insert(offer: <-offer)\n    }\n}\n`\n\nexport function createSaleOffer({itemID, price}, opts = {}) {\n  if (itemID == null)\n    throw new Error(\"createSaleOffer(itemID, price) -- itemID required\")\n  if (price == null)\n    throw new Error(\"createSaleOffer(itemID, price) -- price required\")\n\n  // prettier-ignore\n  return tx([\n    fcl.transaction(CODE),\n    fcl.args([\n      fcl.arg(Number(itemID), t.UInt64),\n      fcl.arg(String(price), t.UFix64),\n    ]),\n    fcl.proposer(fcl.authz),\n    fcl.payer(fcl.authz),\n    fcl.authorizations([\n      fcl.authz\n    ]),\n    fcl.limit(1000)\n  ], opts)\n}\n"]},"metadata":{},"sourceType":"module"}