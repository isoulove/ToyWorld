{"ast":null,"code":"// prettier-ignore\nimport { transaction, limit, proposer, payer, authorizations, authz, cdc } from \"@onflow/fcl\";\nimport { invariant } from \"@onflow/util-invariant\";\nimport { tx } from \"./util/tx\";\nconst CODE = cdc`\n  import FungibleToken from 0xFungibleToken\n  import NonFungibleToken from 0xNonFungibleToken\n  import Kibble from 0xKibble\n  import KittyItems from 0xKittyItems\n  import KittyItemsMarket from 0xKittyItemsMarket\n\n  pub fun hasKibble(_ address: Address): Bool {\n    let receiver = getAccount(address)\n      .getCapability<&Kibble.Vault{FungibleToken.Receiver}>(Kibble.ReceiverPublicPath)\n      .check()\n\n    let balance = getAccount(address)\n      .getCapability<&Kibble.Vault{FungibleToken.Balance}>(Kibble.BalancePublicPath)\n      .check()\n\n    return receiver && balance\n  }\n\n  pub fun hasItems(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&KittyItems.Collection{NonFungibleToken.CollectionPublic, KittyItems.KittyItemsCollectionPublic}>(KittyItems.CollectionPublicPath)\n      .check()\n  }\n\n  pub fun hasMarket(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&KittyItemsMarket.Collection{KittyItemsMarket.CollectionPublic}>(KittyItemsMarket.CollectionPublicPath)\n      .check()\n  }\n\n  transaction {\n    prepare(acct: AuthAccount) {\n      if !hasKibble(acct.address) {\n        if acct.borrow<&Kibble.Vault>(from: Kibble.VaultStoragePath) == nil {\n          acct.save(<-Kibble.createEmptyVault(), to: Kibble.VaultStoragePath)\n        }\n        acct.unlink(Kibble.ReceiverPublicPath)\n        acct.unlink(Kibble.BalancePublicPath)\n        acct.link<&Kibble.Vault{FungibleToken.Receiver}>(Kibble.ReceiverPublicPath, target: Kibble.VaultStoragePath)\n        acct.link<&Kibble.Vault{FungibleToken.Balance}>(Kibble.BalancePublicPath, target: Kibble.VaultStoragePath)\n      }\n\n      if !hasItems(acct.address) {\n        if acct.borrow<&KittyItems.Collection>(from: KittyItems.CollectionStoragePath) == nil {\n          acct.save(<-KittyItems.createEmptyCollection(), to: KittyItems.CollectionStoragePath)\n        }\n        acct.unlink(KittyItems.CollectionPublicPath)\n        acct.link<&KittyItems.Collection{NonFungibleToken.CollectionPublic, KittyItems.KittyItemsCollectionPublic}>(KittyItems.CollectionPublicPath, target: KittyItems.CollectionStoragePath)\n      }\n\n      if !hasMarket(acct.address) {\n        if acct.borrow<&KittyItemsMarket.Collection>(from: KittyItemsMarket.CollectionStoragePath) == nil {\n          acct.save(<-KittyItemsMarket.createEmptyCollection(), to: KittyItemsMarket.CollectionStoragePath)\n        }\n        acct.unlink(KittyItemsMarket.CollectionPublicPath)\n        acct.link<&KittyItemsMarket.Collection{KittyItemsMarket.CollectionPublic}>(KittyItemsMarket.CollectionPublicPath, target:KittyItemsMarket.CollectionStoragePath)\n      }\n    }\n  }\n`;\nexport async function initializeAccount(address, opts = {}) {\n  // prettier-ignore\n  invariant(address != null, \"Tried to initialize an account but no address was supplied\");\n  return tx([transaction(CODE), limit(70), proposer(authz), payer(authz), authorizations([authz])], opts);\n}","map":{"version":3,"sources":["/Users/wuchao/flow/nft/ToyWorld/web/src/flow/initialize-account.tx.js"],"names":["transaction","limit","proposer","payer","authorizations","authz","cdc","invariant","tx","CODE","initializeAccount","address","opts"],"mappings":"AAAA;AACA,SAAQA,WAAR,EAAqBC,KAArB,EAA4BC,QAA5B,EAAsCC,KAAtC,EAA6CC,cAA7C,EAA6DC,KAA7D,EAAoEC,GAApE,QAA8E,aAA9E;AACA,SAAQC,SAAR,QAAwB,wBAAxB;AACA,SAAQC,EAAR,QAAiB,WAAjB;AAEA,MAAMC,IAAI,GAAGH,GAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA5DA;AA8DA,OAAO,eAAeI,iBAAf,CAAiCC,OAAjC,EAA0CC,IAAI,GAAG,EAAjD,EAAqD;AAC1D;AACAL,EAAAA,SAAS,CAACI,OAAO,IAAI,IAAZ,EAAkB,4DAAlB,CAAT;AAEA,SAAOH,EAAE,CACP,CACER,WAAW,CAACS,IAAD,CADb,EAEER,KAAK,CAAC,EAAD,CAFP,EAGEC,QAAQ,CAACG,KAAD,CAHV,EAIEF,KAAK,CAACE,KAAD,CAJP,EAKED,cAAc,CAAC,CAACC,KAAD,CAAD,CALhB,CADO,EAQPO,IARO,CAAT;AAUD","sourcesContent":["// prettier-ignore\nimport {transaction, limit, proposer, payer, authorizations, authz, cdc} from \"@onflow/fcl\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {tx} from \"./util/tx\"\n\nconst CODE = cdc`\n  import FungibleToken from 0xFungibleToken\n  import NonFungibleToken from 0xNonFungibleToken\n  import Kibble from 0xKibble\n  import KittyItems from 0xKittyItems\n  import KittyItemsMarket from 0xKittyItemsMarket\n\n  pub fun hasKibble(_ address: Address): Bool {\n    let receiver = getAccount(address)\n      .getCapability<&Kibble.Vault{FungibleToken.Receiver}>(Kibble.ReceiverPublicPath)\n      .check()\n\n    let balance = getAccount(address)\n      .getCapability<&Kibble.Vault{FungibleToken.Balance}>(Kibble.BalancePublicPath)\n      .check()\n\n    return receiver && balance\n  }\n\n  pub fun hasItems(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&KittyItems.Collection{NonFungibleToken.CollectionPublic, KittyItems.KittyItemsCollectionPublic}>(KittyItems.CollectionPublicPath)\n      .check()\n  }\n\n  pub fun hasMarket(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&KittyItemsMarket.Collection{KittyItemsMarket.CollectionPublic}>(KittyItemsMarket.CollectionPublicPath)\n      .check()\n  }\n\n  transaction {\n    prepare(acct: AuthAccount) {\n      if !hasKibble(acct.address) {\n        if acct.borrow<&Kibble.Vault>(from: Kibble.VaultStoragePath) == nil {\n          acct.save(<-Kibble.createEmptyVault(), to: Kibble.VaultStoragePath)\n        }\n        acct.unlink(Kibble.ReceiverPublicPath)\n        acct.unlink(Kibble.BalancePublicPath)\n        acct.link<&Kibble.Vault{FungibleToken.Receiver}>(Kibble.ReceiverPublicPath, target: Kibble.VaultStoragePath)\n        acct.link<&Kibble.Vault{FungibleToken.Balance}>(Kibble.BalancePublicPath, target: Kibble.VaultStoragePath)\n      }\n\n      if !hasItems(acct.address) {\n        if acct.borrow<&KittyItems.Collection>(from: KittyItems.CollectionStoragePath) == nil {\n          acct.save(<-KittyItems.createEmptyCollection(), to: KittyItems.CollectionStoragePath)\n        }\n        acct.unlink(KittyItems.CollectionPublicPath)\n        acct.link<&KittyItems.Collection{NonFungibleToken.CollectionPublic, KittyItems.KittyItemsCollectionPublic}>(KittyItems.CollectionPublicPath, target: KittyItems.CollectionStoragePath)\n      }\n\n      if !hasMarket(acct.address) {\n        if acct.borrow<&KittyItemsMarket.Collection>(from: KittyItemsMarket.CollectionStoragePath) == nil {\n          acct.save(<-KittyItemsMarket.createEmptyCollection(), to: KittyItemsMarket.CollectionStoragePath)\n        }\n        acct.unlink(KittyItemsMarket.CollectionPublicPath)\n        acct.link<&KittyItemsMarket.Collection{KittyItemsMarket.CollectionPublic}>(KittyItemsMarket.CollectionPublicPath, target:KittyItemsMarket.CollectionStoragePath)\n      }\n    }\n  }\n`\n\nexport async function initializeAccount(address, opts = {}) {\n  // prettier-ignore\n  invariant(address != null, \"Tried to initialize an account but no address was supplied\")\n\n  return tx(\n    [\n      transaction(CODE),\n      limit(70),\n      proposer(authz),\n      payer(authz),\n      authorizations([authz]),\n    ],\n    opts\n  )\n}\n"]},"metadata":{},"sourceType":"module"}